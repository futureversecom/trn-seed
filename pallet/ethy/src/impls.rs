// Copyright 2022-2023 Futureverse Corporation Limited
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// You may obtain a copy of the License at the root of this project source code

use codec::Encode;
use ethabi::Token;
use frame_support::{
	log::{info, warn},
	pallet_prelude::*,
	traits::{OneSessionHandler, UnixTime, ValidatorSet as ValidatorSetT},
};
use frame_system::offchain::SubmitTransaction;
use sp_core::bounded::WeakBoundedVec;
use sp_runtime::{
	generic::DigestItem,
	traits::{AccountIdConversion, Convert, SaturatedConversion, Saturating},
	transaction_validity::{
		InvalidTransaction, TransactionSource, TransactionValidity, ValidTransaction,
	},
	Percent, RuntimeAppPublic,
};
use sp_std::prelude::*;

use seed_pallet_common::{
	log, logger::debug, EthCallFailure, EthCallOracle, EthCallOracleSubscriber, EthereumBridge,
	FinalSessionTracker as FinalSessionTrackerT, XrplBridgeToEthyAdapter,
};
use seed_primitives::ethy::{EthyEcdsaToEthereum, EthyEcdsaToXRPLAccountId};

use crate::{types::*, *};

impl<T: Config> EthereumBridge for Pallet<T> {
	/// Send an event via the bridge
	///  A proof of the event will be generated by notaries (async)
	///
	/// Returns an Id for the proof
	fn send_event(
		source: &H160,
		destination: &H160,
		app_event: &[u8],
	) -> Result<EventProofId, DispatchError> {
		let event_proof_id = NextEventProofId::<T>::get();
		NextEventProofId::<T>::put(event_proof_id.wrapping_add(1));

		let message =
			BoundedVec::try_from(app_event.to_vec()).map_err(|_| Error::<T>::MessageTooLarge)?;
		let event_proof_info = EthereumEventInfo {
			source: *source,
			destination: *destination,
			message,
			validator_set_id: Self::validator_set().id,
			event_proof_id,
		};

		Self::do_request_event_proof(
			event_proof_id,
			EthySigningRequest::Ethereum(event_proof_info),
		);
		Ok(event_proof_id)
	}
}

impl<T: Config> XrplBridgeToEthyAdapter<T::EthyId> for Pallet<T> {
	/// Sign a transaction via ethy for XRPL
	/// Signatures for the tx will be generated by notaries (async)
	///
	/// Returns an Id for the proof
	fn sign_xrpl_transaction(tx_data: &[u8]) -> Result<EventProofId, DispatchError> {
		let event_proof_id = NextEventProofId::<T>::get();
		NextEventProofId::<T>::put(event_proof_id.wrapping_add(1));

		let tx_data =
			BoundedVec::try_from(tx_data.to_vec()).map_err(|_| Error::<T>::MessageTooLarge)?;
		Self::do_request_event_proof(event_proof_id, EthySigningRequest::XrplTx(tx_data));
		Ok(event_proof_id)
	}
	fn validators() -> Vec<T::EthyId> {
		NotaryKeys::<T>::get().into_inner()
	}
	fn xrp_validators() -> Vec<T::EthyId> {
		NotaryXrplKeys::<T>::get().into_inner()
	}
}

impl<T: Config> Pallet<T> {
	// Is the bridge paused?
	pub fn bridge_paused() -> bool {
		let paused_status = BridgePaused::<T>::get();
		paused_status.manual_pause || paused_status.authorities_change
	}

	/// Prunes claim ids that are less than the max contiguous claim id.
	pub fn prune_claim_ids(claim_ids: &mut Vec<EventClaimId>) -> Weight {
		let mut used_weight = Weight::zero();
		// if < 1 element, nothing to do
		if let 0..=1 = claim_ids.len() {
			return used_weight;
		}

		// Keep the last MaxProcessedMessageIds elements in the list
		let removed = claim_ids
			.drain(..claim_ids.len().saturating_sub(T::MaxProcessedMessageIds::get() as usize));
		let removed: Vec<EventClaimId> = removed.collect();

		// Check if we are aggressively pruning and event_ids that have not been processed
		if !removed.is_empty() {
			let mut missing_ids = MissedMessageIds::<T>::get();
			// Add all missing ids from removed to missing
			for id in removed[0]..claim_ids[0] {
				if removed.contains(&id) {
					continue;
				}
				// Insert the missing ID from the removed list into the missing_ids list
				if let Err(idx) = missing_ids.binary_search(&id) {
					missing_ids.insert(idx, id);
				}
			}
			MissedMessageIds::<T>::put(missing_ids);
			used_weight += DbWeight::get().reads_writes(1, 1);
		}

		// get the index of the fist element that's non contiguous.
		let first_noncontinuous_idx = claim_ids.iter().enumerate().position(|(i, &x)| {
			if i > 0 {
				x != claim_ids[i - 1] + 1
			} else {
				false
			}
		});
		// drain the array from start to (first_noncontinuous_idx - 1) since we need the max
		// contiguous element in the pruned vector.
		match first_noncontinuous_idx {
			Some(idx) => claim_ids.drain(..idx - 1),
			None => claim_ids.drain(..claim_ids.len() - 1), // we need the last element to remain
		};

		used_weight
	}

	/// Decode event data into it's respective parts.
	pub fn decode_event_data(
		tx_hash: H256,
		event_data: Vec<u8>,
	) -> Result<(EventClaimId, EventClaim<T::MaxEthData>), DispatchError> {
		// event SendMessage(uint256 messageId, address source, address destination, bytes
		// message, uint256 fee);
		if let [Token::Uint(event_id), Token::Address(source), Token::Address(destination), Token::Bytes(data), Token::Uint(_fee)] =
			ethabi::decode(
				&[
					ParamType::Uint(64),
					ParamType::Address,
					ParamType::Address,
					ParamType::Bytes,
					ParamType::Uint(64),
				],
				event_data.as_slice(),
			)
			.map_err(|_| Error::<T>::InvalidClaim)?
			.as_slice()
		{
			let event_id: EventClaimId = (*event_id).saturated_into();
			let data = BoundedVec::try_from(data.as_slice().to_vec())
				.map_err(|_| Error::<T>::InvalidClaim)?;
			let event_claim = EventClaim {
				tx_hash,
				source: *source,
				destination: *destination,
				data: data.clone(),
			};
			return Ok((event_id, event_claim));
		}
		Err(Error::<T>::InvalidClaim.into())
	}

	// Store an event claim in the pallet to be processed after the ChallengePeriod
	// Ensures the event is not already contained within PendingEventClaims
	// Note. This function does not contain any replay protection logic
	pub(crate) fn do_submit_event(
		event_id: EventClaimId,
		event_claim: EventClaim<T::MaxEthData>,
	) -> DispatchResult {
		ensure!(!PendingEventClaims::<T>::contains_key(event_id), Error::<T>::EventReplayPending);

		let process_at: BlockNumberFor<T> =
			<frame_system::Pallet<T>>::block_number() + ChallengePeriod::<T>::get();
		MessagesValidAt::<T>::try_mutate(process_at, |v| -> DispatchResult {
			v.try_push(event_id).map_err(|_| Error::<T>::MessageTooLarge)?;
			Ok(())
		})?;

		PendingEventClaims::<T>::insert(event_id, &event_claim);
		PendingClaimStatus::<T>::insert(event_id, EventClaimStatus::Pending);
		Self::deposit_event(Event::<T>::EventSubmit {
			event_claim_id: event_id,
			event_claim,
			process_at,
		});
		Ok(())
	}

	pub fn update_xrpl_notary_keys(validator_list: &WeakBoundedVec<T::EthyId, T::MaxAuthorities>) {
		let validators = Self::get_xrpl_notary_keys(&validator_list.clone().into_inner());
		<NotaryXrplKeys<T>>::put(WeakBoundedVec::force_from(
			validators,
			Some(
				"Warning: There are more XRPL Notary Keys than expected. \
				A runtime configuration adjustment may be needed.",
			),
		));
	}

	pub(crate) fn get_xrpl_notary_keys(validator_list: &[T::EthyId]) -> Vec<T::EthyId> {
		// Filter validator_list from WhiteList Validators.
		validator_list
			.iter()
			.filter(|validator| XrplDoorSigners::<T>::get(validator))
			.take(T::MaxXrplKeys::get().into()).cloned()
			.collect()
	}

	/// Check the nodes local keystore for an active (staked) Ethy session key
	/// Returns the public key and index of the key in the current notary set
	pub(crate) fn find_active_ethy_key() -> Option<(T::EthyId, u16)> {
		// Get all signing keys for this protocol 'KeyTypeId'
		let local_keys = T::EthyId::all();
		if local_keys.is_empty() {
			log!(
				error,
				"ðŸ’Ž no signing keys for: {:?}, cannot participate in notarization!",
				T::EthyId::ID
			);
			return None;
		};

		let mut maybe_active_key: Option<(T::EthyId, usize)> = None;
		// search all local ethy keys
		for key in local_keys {
			if let Some(active_key_index) = NotaryKeys::<T>::get().iter().position(|k| k == &key) {
				maybe_active_key = Some((key, active_key_index));
				break;
			}
		}

		// check if locally known keys are in the active validator set
		if maybe_active_key.is_none() {
			log!(error, "ðŸ’Ž no active ethy keys, exiting");
			return None;
		}
		maybe_active_key.map(|(key, idx)| (key, idx as u16))
	}

	/// Handle OCW event notarization protocol for validators
	/// Receives the node's local notary session key and index in the set
	pub(crate) fn do_event_notarization_ocw(active_key: &T::EthyId, authority_index: u16) {
		// do not try to notarize events while the bridge is paused
		if Self::bridge_paused() {
			return;
		}

		// check all pending claims we have _yet_ to notarize and try to notarize them
		// this will be invoked once every block
		// we limit the total claims per invocation using `CLAIMS_PER_BLOCK` so we don't stall block
		// production.
		for event_claim_id in PendingClaimChallenges::<T>::get().iter().take(CLAIMS_PER_BLOCK) {
			let Some(event_claim) = PendingEventClaims::<T>::get(event_claim_id) else {
				// This shouldn't happen
				log!(error, "ðŸ’Ž notarization failed, event claim: {:?} not found", event_claim_id);
				continue;
			};

			// skip if we've notarized it previously
			if <EventNotarizations<T>>::contains_key::<EventClaimId, T::EthyId>(
				*event_claim_id,
				active_key.clone(),
			) {
				log!(trace, "ðŸ’Ž already notarized claim: {:?}, ignoring...", event_claim_id);
				continue;
			}

			let result = Self::offchain_try_notarize_event(*event_claim_id, event_claim);
			log!(trace, "ðŸ’Ž claim verification status: {:?}", &result);
			let payload = NotarizationPayload::Event {
				event_claim_id: *event_claim_id,
				authority_index,
				result: result.clone(),
			};
			let _ = Self::offchain_send_notarization(active_key, payload)
				.map_err(|err| {
					log!(error, "ðŸ’Ž sending notarization failed ðŸ™ˆ, {:?}", err);
				})
				.map(|_| {
					log!(
						info,
						"ðŸ’Ž sent notarization: '{:?}' for claim: {:?}",
						result,
						event_claim_id
					);
				});
		}
	}
	/// Verify a bridge message
	///
	/// `event_claim_id` - The event claim Id
	/// `event_claim` - The event claim info
	/// Checks:
	/// - check Eth full node for transaction status
	/// - tx success
	/// - tx sent to source contract address
	/// - check for exact log data match
	/// - check log source == bridge contract address
	/// - confirmations `>= T::EventConfirmations`
	///
	/// Returns result of the validation
	pub(crate) fn offchain_try_notarize_event(
		event_claim_id: EventClaimId,
		event_claim: EventClaim<T::MaxEthData>,
	) -> EventClaimResult {
		let EventClaim { tx_hash, data, source, destination } = event_claim;
		let maybe_tx_receipt = match T::EthereumRpcClient::get_transaction_receipt(tx_hash) {
			Ok(r) => r,
			Err(err) => {
				log!(error, "ðŸ’Ž eth_getTransactionReceipt({:?}) failed: {:?}", tx_hash, err);
				return EventClaimResult::DataProviderErr;
			}
		};

		let tx_receipt = match maybe_tx_receipt {
			Some(t) => t,
			None => return EventClaimResult::NoTxReceipt,
		};
		let status = tx_receipt.status.unwrap_or_default();
		if status.is_zero() {
			return EventClaimResult::TxStatusFailed;
		}

		// this may be overly restrictive
		// requires the transaction calls the source contract as the entrypoint or fails.
		// example 1: contract A -> bridge contract, ok
		// example 2: contract A -> contract B -> bridge contract, fails
		if tx_receipt.to != Some(source) {
			return EventClaimResult::UnexpectedSource;
		}

		// search for a bridge deposit event in this tx receipt
		let matching_log = tx_receipt.logs.iter().find(|log| {
			log.transaction_hash == Some(tx_hash)
				&& log.topics.contains(&SUBMIT_BRIDGE_EVENT_SELECTOR.into())
		});

		let submitted_event_data = ethabi::encode(&[
			Token::Uint(event_claim_id.into()),
			Token::Address(source),
			Token::Address(destination),
			Token::Bytes(data.into_inner()),
		]);
		if let Some(log) = matching_log {
			// check if the Ethereum event data matches what was reported
			// in the original claim
			if log.data != submitted_event_data {
				log!(
					trace,
					"ðŸ’Ž mismatch in provided data vs. observed data. provided: {:?} observed: {:?}",
					submitted_event_data,
					log.data,
				);
				return EventClaimResult::UnexpectedData;
			}
			if log.address != ContractAddress::<T>::get() {
				return EventClaimResult::UnexpectedContractAddress;
			}
		} else {
			return EventClaimResult::NoTxLogs;
		}

		//  have we got enough block confirmations to be re-org safe?
		let observed_block_number: u64 = tx_receipt.block_number.saturated_into();

		let latest_block: EthBlock =
			match T::EthereumRpcClient::get_block_by_number(LatestOrNumber::Latest) {
				Ok(None) => return EventClaimResult::DataProviderErr,
				Ok(Some(block)) => block,
				Err(err) => {
					log!(error, "ðŸ’Ž eth_getBlockByNumber latest failed: {:?}", err);
					return EventClaimResult::DataProviderErr;
				},
			};

		let latest_block_number = latest_block.number.unwrap_or_default().as_u64();
		let block_confirmations = latest_block_number.saturating_sub(observed_block_number);
		if block_confirmations < EventBlockConfirmations::<T>::get() {
			return EventClaimResult::NotEnoughConfirmations;
		}

		EventClaimResult::Valid
	}

	/// Handle OCW eth call checking protocol for validators
	/// Receives the node's local notary session key and index in the set
	pub(crate) fn do_call_notarization_ocw(active_key: &T::EthyId, authority_index: u16) {
		// we limit the total claims per invocation using `CALLS_PER_BLOCK` so we don't stall block
		// production
		for call_id in EthCallRequests::<T>::get().iter().take(CALLS_PER_BLOCK) {
			// skip if we've notarized it previously
			if <EthCallNotarizations<T>>::contains_key::<EthCallId, T::EthyId>(
				*call_id,
				active_key.clone(),
			) {
				log!(trace, "ðŸ’Ž already notarized call: {:?}, ignoring...", call_id);
				continue;
			}

			if let Some(request) = EthCallRequestInfo::<T>::get(call_id) {
				let result = Self::offchain_try_eth_call(&request);
				log!(trace, "ðŸ’Ž checked call status: {:?}", &result);
				let payload =
					NotarizationPayload::Call { call_id: *call_id, authority_index, result };
				let _ = Self::offchain_send_notarization(active_key, payload)
					.map_err(|err| {
						log!(error, "ðŸ’Ž sending notarization failed ðŸ™ˆ, {:?}", err);
					})
					.map(|_| {
						log!(info, "ðŸ’Ž sent notarization: '{:?}' for call: {:?}", result, call_id,);
					});
			} else {
				// should not happen
				log!(error, "ðŸ’Ž empty call for: {:?}", call_id);
			}
		}
	}

	/// Performs an `eth_call` request to the bridged ethereum network
	///
	/// The call will be executed at `try_block_number` if it is within `max_block_look_behind`
	/// blocks of the latest ethereum block, otherwise the call is executed at the latest ethereum
	/// block.
	///
	/// `request` - details of the `eth_call` request to perform
	/// `try_block_number` - a block number to try the call at `latest - max_block_look_behind <= t
	/// < latest` `max_block_look_behind` - max ethereum blocks to look back from head
	pub(crate) fn offchain_try_eth_call(
		request: &CheckedEthCallRequest<T::MaxEthData>,
	) -> CheckedEthCallResult {
		// OCW has 1 block to do all its stuff, so needs to be kept light
		//
		// basic flow of this function:
		// 1) get latest ethereum block
		// 2) check relayed block # and timestamp is within acceptable range (based on
		// `max_block_look_behind`) 3a) within range: do an eth_call at the relayed block
		// 3b) out of range: do an eth_call at block number latest
		let latest_block: EthBlock =
			match T::EthereumRpcClient::get_block_by_number(LatestOrNumber::Latest) {
				Ok(None) => return CheckedEthCallResult::DataProviderErr,
				Ok(Some(block)) => block,
				Err(err) => {
					log!(error, "ðŸ’Ž eth_getBlockByNumber latest failed: {:?}", err);
					return CheckedEthCallResult::DataProviderErr;
				},
			};
		// some future proofing/protections if timestamps or block numbers are de-synced, stuck, or
		// missing this protocol should vote to abort
		let latest_eth_block_timestamp: u64 = latest_block.timestamp.saturated_into();
		if latest_eth_block_timestamp == u64::MAX {
			return CheckedEthCallResult::InvalidTimestamp;
		}
		// latest ethereum block timestamp should be after the request
		if latest_eth_block_timestamp < request.timestamp {
			return CheckedEthCallResult::InvalidTimestamp;
		}
		let latest_eth_block_number = match latest_block.number {
			Some(number) => {
				if number.is_zero() || number.low_u64() == u64::MAX {
					return CheckedEthCallResult::InvalidEthBlock;
				}
				number.low_u64()
			},
			None => return CheckedEthCallResult::InvalidEthBlock,
		};

		// check relayed block # and timestamp is within acceptable range
		let mut target_block_number = latest_eth_block_number;
		let mut target_block_timestamp = latest_eth_block_timestamp;

		// there can be delay between challenge submission and execution
		// this should be factored into the acceptable block window, in normal conditions is should
		// be < 5s
		let check_delay = T::UnixTime::now().as_secs().saturating_sub(request.check_timestamp);
		let extra_look_behind = check_delay / 12_u64; // lenient here, any delay >= 12s gets an extra block

		let oldest_acceptable_eth_block = latest_eth_block_number
			.saturating_sub(request.max_block_look_behind)
			.saturating_sub(extra_look_behind);

		if request.try_block_number >= oldest_acceptable_eth_block
			&& request.try_block_number < latest_eth_block_number
		{
			let target_block: EthBlock = match T::EthereumRpcClient::get_block_by_number(
				LatestOrNumber::Number(request.try_block_number),
			) {
				Ok(None) => return CheckedEthCallResult::DataProviderErr,
				Ok(Some(block)) => block,
				Err(err) => {
					log!(error, "ðŸ’Ž eth_getBlockByNumber latest failed: {:?}", err);
					return CheckedEthCallResult::DataProviderErr;
				},
			};
			target_block_number = request.try_block_number;
			target_block_timestamp = target_block.timestamp.saturated_into();
		}

		let return_data = match T::EthereumRpcClient::eth_call(
			request.target,
			&request.input,
			LatestOrNumber::Number(target_block_number),
		) {
			Ok(data) => {
				if data.is_empty() {
					return CheckedEthCallResult::ReturnDataEmpty;
				} else {
					data
				}
			},
			Err(err) => {
				log!(error, "ðŸ’Ž eth_call at: {:?}, failed: {:?}", target_block_number, err);
				return CheckedEthCallResult::DataProviderErr;
			},
		};

		// valid returndata is ethereum abi encoded and therefore always >= 32 bytes
		match return_data.try_into() {
			Ok(r) => CheckedEthCallResult::Ok(r, target_block_number, target_block_timestamp),
			Err(_) => CheckedEthCallResult::ReturnDataExceedsLimit,
		}
	}

	/// Send a notarization for the given claim
	fn offchain_send_notarization(
		key: &T::EthyId,
		payload: NotarizationPayload,
	) -> Result<(), Error<T>> {
		let signature =
			key.sign(&payload.encode()).ok_or(<Error<T>>::OffchainUnsignedTxSignedPayload)?;

		let call = pallet::Call::submit_notarization { payload, signature };

		// Retrieve the signer to sign the payload
		SubmitTransaction::<T, Call<T>>::submit_unsigned_transaction(call.into())
			.map_err(|_| <Error<T>>::OffchainUnsignedTxSignedPayload)
	}

	/// Return the active Ethy validator set.
	pub fn validator_set() -> ValidatorSet<T::EthyId> {
		let validator_keys = NotaryKeys::<T>::get();
		ValidatorSet::<T::EthyId> {
			proof_threshold: T::NotarizationThreshold::get().mul_ceil(validator_keys.len() as u32),
			validators: validator_keys.into_inner(),
			id: NotarySetId::<T>::get(),
		}
	}

	/// Handle a submitted event notarization
	pub(crate) fn handle_event_notarization(
		event_claim_id: EventClaimId,
		result: EventClaimResult,
		notary_id: &T::EthyId,
	) -> DispatchResult {
		ensure!(
			PendingClaimStatus::<T>::get(event_claim_id) == Some(EventClaimStatus::Challenged),
			Error::<T>::InvalidClaim
		);

		// Store the new notarization
		<EventNotarizations<T>>::insert::<EventClaimId, T::EthyId, EventClaimResult>(
			event_claim_id,
			notary_id.clone(),
			result,
		);

		// Count notarization votes
		let notary_count = T::AuthoritySet::validators().len() as u32;
		let mut yay_count = 0_u32;
		let mut nay_count = 0_u32;
		// TODO: store the count
		for (_id, result) in <EventNotarizations<T>>::iter_prefix(event_claim_id) {
			match result {
				EventClaimResult::Valid => yay_count += 1,
				_ => nay_count += 1,
			}
		}

		if Percent::from_rational(nay_count, notary_count)
			> (Percent::from_parts(100_u8 - T::NotarizationThreshold::get().deconstruct()))
		{
			// Claim is invalid (nays > (100% - NotarizationThreshold))
			Self::handle_invalid_claim(event_claim_id)?;
		} else if Percent::from_rational(yay_count, notary_count) >= T::NotarizationThreshold::get()
		{
			// Claim is valid
			Self::handle_valid_claim(event_claim_id)?;
		}

		Ok(())
	}

	/// Handle claim after challenge has proven claim to be invalid
	/// Slash relayer and pay slashed amount to challenger
	/// repay challenger bond to challenger
	/// Remove the active relayer
	pub(crate) fn handle_invalid_claim(event_claim_id: EventClaimId) -> DispatchResult {
		if let Some(cursor) = <EventNotarizations<T>>::clear_prefix(
			event_claim_id,
			NotaryKeys::<T>::decode_len().unwrap_or(1_000) as u32,
			None,
		)
		.maybe_cursor
		{
			log!(error, "ðŸ’Ž cleaning storage entries failed: {:?}", cursor);
			return Err(Error::<T>::Internal.into());
		}
		PendingClaimChallenges::<T>::mutate(|event_ids| {
			event_ids
				.iter()
				.position(|x| *x == event_claim_id)
				.map(|idx| event_ids.remove(idx));
		});

		if let Some(_event_claim) = PendingEventClaims::<T>::take(event_claim_id) {
			if let Some((challenger, bond_amount)) = <ChallengerAccount<T>>::take(event_claim_id) {
				// Challenger is correct, the event is invalid.
				// Return challenger bond to challenger and reward challenger with relayer bond
				T::MultiCurrency::release_hold(
					T::BridgePalletId::get(),
					&challenger,
					T::NativeAssetId::get(),
					bond_amount,
				)?;

				if let Some(relayer) = Relayer::<T>::get() {
					// Relayer bond goes to challenger
					let relayer_paid_bond = <RelayerPaidBond<T>>::take(relayer.clone());
					T::MultiCurrency::spend_hold(
						T::BridgePalletId::get(),
						&relayer,
						T::NativeAssetId::get(),
						&[(challenger, relayer_paid_bond)],
					)?;
					// Relayer has been slashed, remove their stored bond amount and set relayer to
					// None
					<Relayer<T>>::kill();
				};

				PendingClaimStatus::<T>::remove(event_claim_id);
				Self::deposit_event(Event::<T>::RelayerSet { relayer: None });
			} else {
				// This shouldn't happen
				log!(error, "ðŸ’Ž unexpected missing challenger account");
			}
			Self::deposit_event(Event::<T>::Invalid { event_claim_id });
			Ok(())
		} else {
			log!(error, "ðŸ’Ž unexpected empty claim");
			Err(Error::<T>::InvalidClaim.into())
		}
	}

	/// Handle claim after challenge has proven claim to be valid
	/// Pay challenger bond to relayer
	pub(crate) fn handle_valid_claim(event_claim_id: EventClaimId) -> DispatchResult {
		// no need to track info on this claim any more since it's approved
		if let Some(cursor) = <EventNotarizations<T>>::clear_prefix(
			event_claim_id,
			NotaryKeys::<T>::decode_len().unwrap_or(1_000) as u32,
			None,
		)
		.maybe_cursor
		{
			log!(error, "ðŸ’Ž cleaning storage entries failed: {:?}", cursor);
			return Err(Error::<T>::Internal.into());
		}
		// Remove the claim from pending_claim_challenges
		PendingClaimChallenges::<T>::mutate(|event_ids| {
			event_ids
				.iter()
				.position(|x| *x == event_claim_id)
				.map(|idx| event_ids.remove(idx));
		});

		if PendingEventClaims::<T>::contains_key(event_claim_id) {
			if let Some(relayer) = Relayer::<T>::get() {
				if let Some((challenger, bond_amount)) =
					<ChallengerAccount<T>>::take(event_claim_id)
				{
					// Challenger is incorrect, the event is valid. Send funds to relayer
					T::MultiCurrency::spend_hold(
						T::BridgePalletId::get(),
						&challenger,
						T::NativeAssetId::get(),
						&[(relayer, bond_amount)],
					)?;
				} else {
					// This shouldn't happen
					log!(error, "ðŸ’Ž unexpected missing challenger account");
				}

				PendingClaimStatus::<T>::insert(event_claim_id, EventClaimStatus::ProvenValid);
				Self::deposit_event(Event::<T>::Verified { event_claim_id });
			} else {
				log!(error, "ðŸ’Ž No relayer set");
			}
		} else {
			log!(error, "ðŸ’Ž unexpected empty claim");
			return Err(Error::<T>::InvalidClaim.into());
		}
		Ok(())
	}

	/// Handle a submitted call notarization
	pub(crate) fn handle_call_notarization(
		call_id: EthCallId,
		result: CheckedEthCallResult,
		notary_id: &T::EthyId,
	) -> DispatchResult {
		if !EthCallRequestInfo::<T>::contains_key(call_id) {
			// there's no claim active
			return Err(Error::<T>::InvalidClaim.into());
		}

		// Record the notarization (ensures the validator won't resubmit it)
		<EthCallNotarizations<T>>::insert::<EventClaimId, T::EthyId, CheckedEthCallResult>(
			call_id,
			notary_id.clone(),
			result,
		);

		// notify subscribers of a notarized eth_call outcome and clean upstate
		let do_callback_and_clean_up = |result: CheckedEthCallResult| {
			match result {
				CheckedEthCallResult::Ok(return_data, block, timestamp) => {
					T::EthCallSubscribers::on_eth_call_complete(
						call_id,
						&return_data,
						block,
						timestamp,
					)
				},
				CheckedEthCallResult::ReturnDataEmpty => T::EthCallSubscribers::on_eth_call_failed(
					call_id,
					EthCallFailure::ReturnDataEmpty,
				),
				CheckedEthCallResult::ReturnDataExceedsLimit => {
					T::EthCallSubscribers::on_eth_call_failed(
						call_id,
						EthCallFailure::ReturnDataExceedsLimit,
					)
				},
				_ => T::EthCallSubscribers::on_eth_call_failed(call_id, EthCallFailure::Internal),
			}
			if let Some(cursor) = <EthCallNotarizations<T>>::clear_prefix(
				call_id,
				NotaryKeys::<T>::decode_len().unwrap_or(1_000) as u32,
				None,
			)
			.maybe_cursor
			{
				log!(error, "ðŸ’Ž cleaning storage entries failed: {:?}", cursor);
				return Err(Error::<T>::Internal.into());
			};
			EthCallNotarizationsAggregated::<T>::remove(call_id);
			EthCallRequestInfo::<T>::remove(call_id);
			EthCallRequests::<T>::mutate(|requests| {
				requests.iter().position(|x| *x == call_id).map(|idx| requests.remove(idx));
			});

			Ok(())
		};

		let mut notarizations =
			EthCallNotarizationsAggregated::<T>::get(call_id).unwrap_or_default();
		// increment notarization count for this result
		*notarizations.entry(result).or_insert(0) += 1;

		let notary_count = T::AuthoritySet::validators().len() as u32;
		let notarization_threshold = T::NotarizationThreshold::get();
		let mut total_count = 0;
		for (result, count) in notarizations.iter() {
			// is there consensus on `result`?
			if Percent::from_rational(*count, notary_count) >= notarization_threshold {
				return do_callback_and_clean_up(*result);
			}
			total_count += count;
		}

		let outstanding_count = notary_count.saturating_sub(total_count);
		let can_reach_consensus = notarizations.iter().any(|(_, count)| {
			Percent::from_rational(count + outstanding_count, notary_count)
				>= notarization_threshold
		});
		// cannot or will not reach consensus based on current notarizations
		if total_count == notary_count || !can_reach_consensus {
			return do_callback_and_clean_up(result);
		}

		// update counts
		EthCallNotarizationsAggregated::<T>::insert(call_id, notarizations);
		Ok(())
	}

	/// Handle changes to the authority set
	/// This is called 5 minutes before the end of an era which gives the bridge time to update
	/// keys on the contract
	/// This could be called when validators rotate their keys, we don't want to
	/// change this until the era has changed to avoid generating proofs for small set changes or
	/// too frequently
	pub(crate) fn handle_authorities_change() {
		// ### Session life cycle
		//  rotate_session
		//    end_session (end just been)
		//    start_session (start now)
		//       Queue at end of session - 5 minutes
		// 	  -> block on_initialize if NextAuthorityChange(n) <- this function is CALLED here
		//    new_session (start now + 1)
		debug!(target: "ethy-pallet", "ðŸ’Ž handling authority set change..");
		let next_keys = &NextNotaryKeys::<T>::get();
		let next_validator_set_id = NotarySetId::<T>::get().wrapping_add(1);

		// TODO: probably don't need both consensus logs...
		let new_validator_addresses: Vec<Token> = next_keys
			.into_iter()
			.map(|k| EthyEcdsaToEthereum::convert(k.as_ref()))
			.map(|k| Token::Address(k.into()))
			.collect();
		let new_validator_set_message = ethabi::encode(&[
			Token::Array(new_validator_addresses),
			Token::Uint(next_validator_set_id.into()),
		]);

		// notify ethereum contract about validator set change
		if let Ok(event_proof_id) = Self::send_event(
			&T::BridgePalletId::get().into_account_truncating(),
			&ContractAddress::<T>::get(),
			new_validator_set_message.as_slice(),
		) {
			// Signal the Event Id that will be used for the proof of validator set change.
			// Any observer can subscribe to this event and submit the resulting proof to keep
			// the validator set on the Ethereum bridge contract updated.
			Self::deposit_event(Event::<T>::AuthoritySetChange {
				event_proof_id,
				validator_set_id: next_validator_set_id,
			});
			NotarySetProofId::<T>::put(event_proof_id);
			// Indicate that the authorities have been changed
			AuthoritiesChangedThisEra::<T>::put(true);
		}

		// request for proof xrpl - SignerListSet
		debug!(target: "ethy-pallet", "ðŸ’Ž next keys: {:?}", next_keys);
		let mut next_notary_xrpl_keys = Self::get_xrpl_notary_keys(next_keys);
		let mut notary_xrpl_keys = NotaryXrplKeys::<T>::get().into_inner();
		// sort to avoid same key set shuffles.
		next_notary_xrpl_keys.sort();
		notary_xrpl_keys.sort();

		// if the xrpl notaries are the same, do not request for xrpl proof
		if notary_xrpl_keys == next_notary_xrpl_keys {
			info!(target: "ethy-pallet", "ðŸ’Ž notary xrpl keys unchanged {:?}", next_notary_xrpl_keys);
			// Pause the bridge
			BridgePaused::<T>::mutate(|p| p.authorities_change = true);
			<NextAuthorityChange<T>>::kill();
			return;
		}

		let signer_entries = next_notary_xrpl_keys
			.into_iter()
			.map(|k| EthyEcdsaToXRPLAccountId::convert(k.as_ref()))
			// TODO(surangap): Add a proper way to store XRPL weights if we intend to allow
			// having different weights
			.map(|entry| (entry.into(), 1_u16))
			.collect::<Vec<_>>();

		debug!(target: "ethy-pallet", "ðŸ’Ž xrpl new signer entries: {:?}", signer_entries);
		match T::XrplBridgeAdapter::submit_signer_list_set_request(signer_entries) {
			Ok(event_proof_id) => {
				// Signal the Event Id that will be used for the proof of xrpl notary set change.
				// Any observer can subscribe to this event and submit the resulting proof to keep
				// the authority set of the xrpl door address updated.
				Self::deposit_event(Event::<T>::XrplAuthoritySetChange {
					event_proof_id,
					validator_set_id: next_validator_set_id,
				});
				XrplNotarySetProofId::<T>::put(event_proof_id);
			},
			Err(e) => {
				warn!(target: "ethy-pallet", "ðŸ’Ž Failed to send xrpl signer list set request {:?}", e);
				Self::deposit_event(Event::<T>::XrplAuthoritySetChangeRequestFailed { error: e });
			},
		};

		// Pause the bridge
		BridgePaused::<T>::mutate(|p| p.authorities_change = true);
		<NextAuthorityChange<T>>::kill();
	}

	/// Finalize authority changes, set new notary keys, unpause bridge and increase set id
	pub fn do_finalise_authorities_change(
		next_notary_keys: WeakBoundedVec<T::EthyId, T::MaxAuthorities>,
	) {
		debug!(target: "ethy-pallet", "ðŸ’Ž session & era ending, set new validator keys");

		// notify ethy-gadget about validator set change
		let next_validator_set_id = NotarySetId::<T>::get().wrapping_add(1);
		let log = DigestItem::Consensus(
			ETHY_ENGINE_ID,
			ConsensusLog::AuthoritiesChange(ValidatorSet {
				validators: next_notary_keys.clone().into_inner(),
				id: next_validator_set_id,
				proof_threshold: T::NotarizationThreshold::get()
					.mul_ceil(next_notary_keys.len() as u32),
			})
			.encode(),
		);
		<frame_system::Pallet<T>>::deposit_log(log);

		// Unpause the bridge
		BridgePaused::<T>::mutate(|p| p.authorities_change = false);
		// A proof should've been generated now so we can reactivate the bridge with the new
		// validator set
		AuthoritiesChangedThisEra::<T>::kill();
		// Store the new keys and increment the validator set id
		// Next notary keys should be unset, until populated by new session logic
		NotaryKeys::<T>::put(&next_notary_keys);
		Self::update_xrpl_notary_keys(&next_notary_keys);
		NotarySetId::<T>::mutate(|next_set_id| *next_set_id = next_set_id.wrapping_add(1));
	}

	/// Submit an event proof signing request in the block, for use by the ethy-gadget protocol
	pub(crate) fn do_request_event_proof(
		event_proof_id: EventProofId,
		request: EthySigningRequest<T::MaxEthData>,
	) {
		// if bridge is paused (e.g transitioning authority set at the end of an era)
		// delay proofs until it is ready again
		if Self::bridge_paused() {
			PendingEventProofs::<T>::insert(event_proof_id, request);
			Self::deposit_event(Event::<T>::ProofDelayed { event_proof_id });
			return;
		}

		// check if validator set id is different from the one that is active
		// If it is, reset the request id to the current one.
		let mut request = request;
		if let EthySigningRequest::Ethereum(ethereum_event_info) = &request {
			let validator_set_id = NotarySetId::<T>::get();
			if validator_set_id > ethereum_event_info.validator_set_id {
				request = EthySigningRequest::Ethereum(EthereumEventInfo {
					source: ethereum_event_info.source,
					destination: ethereum_event_info.destination,
					message: ethereum_event_info.message.clone(),
					validator_set_id,
					event_proof_id: ethereum_event_info.event_proof_id,
				});
			}
		}
		let log: DigestItem = DigestItem::Consensus(
			ETHY_ENGINE_ID,
			ConsensusLog::<T::AccountId>::OpaqueSigningRequest {
				chain_id: request.chain_id(),
				data: request.data(),
				event_proof_id,
			}
			.encode(),
		);
		<frame_system::Pallet<T>>::deposit_log(log);
		Self::deposit_event(Event::<T>::EventSend { event_proof_id, signing_request: request });
	}
}

impl<T: Config> frame_support::unsigned::ValidateUnsigned for Pallet<T> {
	type Call = Call<T>;

	fn validate_unsigned(_source: TransactionSource, call: &Self::Call) -> TransactionValidity {
		if let Call::submit_notarization { ref payload, ref signature } = call {
			// notarization must be from an active notary
			let notary_keys = NotaryKeys::<T>::get();
			let notary_public_key = match notary_keys.get(payload.authority_index() as usize) {
				Some(id) => id,
				None => return InvalidTransaction::BadProof.into(),
			};
			// notarization must not be a duplicate/equivocation
			if <EventNotarizations<T>>::contains_key(payload.payload_id(), notary_public_key) {
				log!(
					error,
					"ðŸ’Ž received equivocation from: {:?} on {:?}",
					notary_public_key,
					payload.payload_id()
				);
				return InvalidTransaction::BadProof.into();
			}
			// notarization is signed correctly
			if !(notary_public_key.verify(&payload.encode(), signature)) {
				return InvalidTransaction::BadProof.into();
			}
			ValidTransaction::with_tag_prefix("eth-bridge")
				.priority(UNSIGNED_TXS_PRIORITY)
				// 'provides' must be unique for each submission on the network (i.e. unique for
				// each claim id and validator)
				.and_provides([
					b"notarize",
					&payload.type_id().to_be_bytes(),
					&payload.payload_id().to_be_bytes(),
					&(payload.authority_index() as u64).to_be_bytes(),
				])
				.longevity(3)
				.propagate(true)
				.build()
		} else {
			InvalidTransaction::Call.into()
		}
	}
}

impl<T: Config> sp_runtime::BoundToRuntimeAppPublic for Pallet<T> {
	type Public = T::EthyId;
}

impl<T: Config> OneSessionHandler<T::AccountId> for Pallet<T> {
	type Key = T::EthyId;

	fn on_genesis_session<'a, I>(validators: I)
	where
		I: Iterator<Item = (&'a T::AccountId, T::EthyId)>,
	{
		let keys = validators.map(|x| x.1).collect::<Vec<_>>();
		let bounded_keys = WeakBoundedVec::<_, T::MaxAuthorities>::force_from(
			keys.clone(),
			Some(
				"Warning: The genesis session has more validators than expected. \
				A runtime configuration adjustment may be needed.",
			),
		);
		if !keys.is_empty() {
			assert!(NotaryKeys::<T>::decode_len().is_none(), "NotaryKeys are already initialized!");
			NotaryKeys::<T>::put(&bounded_keys);
			Self::update_xrpl_notary_keys(&bounded_keys);
		}
	}

	fn on_new_session<'a, I>(_changed: bool, _validators: I, queued_validators: I)
	where
		I: Iterator<Item = (&'a T::AccountId, T::EthyId)>,
	{
		// Store the keys for usage next session
		let next_authorities = queued_validators.map(|(_, k)| k).collect::<Vec<_>>();
		let next_bounded_authorities = WeakBoundedVec::<_, T::MaxAuthorities>::force_from(
			next_authorities,
			Some(
				"Warning: The session has more validators than expected. \
				A runtime configuration adjustment may be needed.",
			),
		);
		<NextNotaryKeys<T>>::put(next_bounded_authorities);

		if T::FinalSessionTracker::is_active_session_final() {
			// Next authority change is 5 minutes before this session ends
			// (Just before the start of the next epoch)
			// next_block = current_block + epoch_duration - AuthorityChangeDelay
			let epoch_duration: BlockNumberFor<T> = T::EpochDuration::get().saturated_into();
			let next_block: BlockNumberFor<T> = <frame_system::Pallet<T>>::block_number()
				.saturating_add(epoch_duration.saturating_sub(T::AuthorityChangeDelay::get()));
			<NextAuthorityChange<T>>::put(next_block);
		}
	}

	/// A notification for end of the session.
	///
	/// Note it is triggered before any [`SessionManager::end_session`] handlers,
	/// so we can still affect the validator set.
	fn on_before_session_ending() {
		// Re-activate the bridge, allowing claims & proofs again
		if T::FinalSessionTracker::is_active_session_final() {
			// Get the next_notary_keys for the next era
			let next_notary_keys = NextNotaryKeys::<T>::get();

			if !AuthoritiesChangedThisEra::<T>::get() {
				// The authorities haven't been changed yet
				// This could be due to a new era being forced before the final session
				Self::handle_authorities_change();

				// Schedule an un-pausing of the bridge to give the relayer time to relay the
				// authority set change.
				let scheduled_block =
					<frame_system::Pallet<T>>::block_number() + T::AuthorityChangeDelay::get();
				if T::Scheduler::schedule(
					DispatchTime::At(scheduled_block),
					None,
					SCHEDULER_PRIORITY,
					frame_system::RawOrigin::None.into(),
					Call::finalise_authorities_change { next_notary_keys }.into(),
				)
				.is_err()
				{
					// The scheduler failed for some reason, throw a log and event
					Self::deposit_event(Event::<T>::FinaliseScheduleFail { scheduled_block });
					log!(warn, "ðŸ’Ž Unpause bridge schedule failed");
				}
			} else {
				// Authorities have been changed, finalise those changes immediately
				Self::do_finalise_authorities_change(next_notary_keys);
			}
		}
	}
	fn on_disabled(_i: u32) {}
}

impl<T: Config> EthCallOracle for Pallet<T> {
	type Address = EthAddress;
	type CallId = EthCallId;
	/// Request an eth_call on some `target` contract with `input` on the bridged ethereum network
	/// Pre-checks are performed based on `max_block_look_behind` and `try_block_number`
	/// `timestamp` - cennznet timestamp of the request
	/// `try_block_number` - ethereum block number hint
	///
	/// Returns a call Id for subscribers
	fn checked_eth_call(
		target: &Self::Address,
		input: &[u8],
		timestamp: u64,
		try_block_number: u64,
		max_block_look_behind: u64,
	) -> Self::CallId {
		// store the job for validators to process async
		let call_id = NextEthCallId::<T>::get();
		let input = BoundedVec::truncate_from(input.to_vec());
		EthCallRequestInfo::<T>::insert(
			call_id,
			CheckedEthCallRequest {
				check_timestamp: T::UnixTime::now().as_secs(),
				input,
				target: *target,
				timestamp,
				try_block_number,
				max_block_look_behind,
			},
		);
		EthCallRequests::<T>::mutate(|v| {
			let mut call_ids = v.clone().into_inner();
			call_ids.push(call_id);
			let call_ids_bounded = WeakBoundedVec::force_from(
				call_ids,
				Some(
					"Warning: There are more EthCallRequests than expected. \
								A runtime configuration adjustment may be needed.",
				),
			);
			*v = call_ids_bounded;
		});
		NextEthCallId::<T>::put(call_id + 1);

		call_id
	}
}
