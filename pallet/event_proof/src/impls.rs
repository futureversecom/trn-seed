use codec::Encode;
use frame_support::{
	pallet_prelude::*, traits::ValidatorSet as ValidatorSetT,
	weights::constants::RocksDbWeight as DbWeight,
};
use frame_system::offchain::SubmitTransaction;
use sp_runtime::{
	generic::DigestItem,
	transaction_validity::{
		InvalidTransaction, TransactionSource, TransactionValidity, ValidTransaction,
	},
	Percent, RuntimeAppPublic,
};
use sp_std::prelude::*;

use seed_pallet_common::{log, EventProofAdapter};
use seed_primitives::validator::{ConsensusLog, EventClaimId, EventProofId};

use crate::{types::SigningRequest, *};

impl<T: Config> Pallet<T> {
	/// Submit an event proof signing request in the block, for use by the ethy-gadget protocol
	pub(crate) fn do_request_event_proof(event_proof_id: EventProofId, request: SigningRequest) {
		// if bridge is paused (e.g transitioning authority set at the end of an era)
		// delay proofs until it is ready again
		if Self::bridge_paused() {
			PendingEventProofs::<T>::insert(event_proof_id, request);
			Self::deposit_event(Event::<T>::ProofDelayed(event_proof_id));
			return
		}

		let log: DigestItem = DigestItem::Consensus(
			ENGINE_ID,
			ConsensusLog::<T::AccountId>::OpaqueSigningRequest {
				chain_id: request.chain_id(),
				data: request.data(),
				event_proof_id,
			}
			.encode(),
		);
		<frame_system::Pallet<T>>::deposit_log(log);
		Self::deposit_event(Event::<T>::EventSend { event_proof_id, signing_request: request });
	}
}

impl<T: Config> EventProofAdapter for Module<T> {
	/// Sign a transaction via ethy for XRPL
	/// Signatures for the tx will be generated by notaries (async)
	///
	/// Returns an Id for the proof
	fn sign_xrpl_transaction(tx_data: &[u8]) -> Result<EventProofId, DispatchError> {
		let event_proof_id = Self::next_event_proof_id();
		NextEventProofId::<T>::put(event_proof_id.wrapping_add(1));

		Self::do_request_event_proof(event_proof_id, SigningRequest::XrplTx(tx_data.to_vec()));
		Ok(event_proof_id)
	}
}
