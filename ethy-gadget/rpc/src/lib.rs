// Copyright (C) 2020-2021 Parity Technologies (UK) Ltd. & Centrality Investments Ltd
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

//! RPC API for Ethy.

#![warn(missing_docs)]

use codec::Decode;
use futures::{FutureExt, StreamExt};
use jsonrpsee::{core::RpcResult, proc_macros::rpc, PendingSubscription};
use log::warn;
use sc_client_api::backend::AuxStore;
use sc_rpc::SubscriptionTaskExecutor;
use sp_api::{BlockId, ProvideRuntimeApi};
use sp_core::H256;
use sp_runtime::traits::{Block, Convert};
use std::{marker::PhantomData, ops::Deref, sync::Arc};

use ethy_gadget::{notification::EthyEventProofStream, EthyEcdsaToEthereum};
use seed_primitives::ethy::{
	EthyApi as EthyRuntimeApi, EventProofId, VersionedEventProof, ETHY_ENGINE_ID,
};

mod notification;
use notification::EventProofResponse;

/// Provides RPC methods for interacting with Ethy.
#[allow(clippy::needless_return)]
#[rpc(client, server, namespace = "ethy")]
pub trait EthyApi<Notification> {
	/// Returns event proofs generated by Ethy
	#[subscription(name = "subscribeEventProofs" => "eventProofs", unsubscribe = "unsubscribeEventProofs", item = Notification)]
	fn subscribe_event_proofs(&self);

	/// Query a proof for a known event Id. Returns `null` if missing
	#[method(name = "getEventProof")]
	fn get_event_proof(&self, event_id: EventProofId) -> RpcResult<Option<Notification>>;
}

/// Implements the EthyApi RPC trait for interacting with ethy-gadget.
pub struct EthyRpcHandler<C, B> {
	event_proof_stream: EthyEventProofStream,
	executor: SubscriptionTaskExecutor,
	/// Handle to a client + backend
	client: Arc<C>,
	phantom: PhantomData<B>,
}

impl<C, B> EthyRpcHandler<C, B>
where
	B: Block<Hash = H256>,
	C: ProvideRuntimeApi<B> + AuxStore + Send + Sync + 'static,
	C::Api: EthyRuntimeApi<B>,
{
	/// Creates a new EthyRpcHandler instance.
	pub fn new(
		event_proof_stream: EthyEventProofStream,
		executor: SubscriptionTaskExecutor,
		client: Arc<C>,
	) -> Self {
		Self { client, event_proof_stream, executor, phantom: PhantomData }
	}
}

impl<C, B> EthyApiServer<EventProofResponse> for EthyRpcHandler<C, B>
where
	B: Block<Hash = H256>,
	C: ProvideRuntimeApi<B> + AuxStore + Send + Sync + 'static,
	C::Api: EthyRuntimeApi<B>,
{
	fn subscribe_event_proofs(&self, pending: PendingSubscription) {
		let client_handle = self.client.clone();
		let stream = self
			.event_proof_stream
			.subscribe()
			.map(move |p| build_event_proof_response::<C, B>(&client_handle, p));

		let fut = async move {
			// asynchronous portion of the function
			if let Some(mut sink) = pending.accept() {
				sink.pipe_from_stream(stream).await;
			}
		};

		self.executor.spawn("ethy-rpc-subscription", Some("rpc"), fut.boxed());
	}

	fn get_event_proof(&self, event_id: EventProofId) -> RpcResult<Option<EventProofResponse>> {
		if let Ok(maybe_encoded_proof) = self
			.client
			.get_aux([&ETHY_ENGINE_ID[..], &event_id.to_be_bytes()[..]].concat().as_ref())
		{
			if let Some(encoded_proof) = maybe_encoded_proof {
				if let Ok(versioned_proof) = VersionedEventProof::decode(&mut &encoded_proof[..]) {
					let event_proof_response =
						build_event_proof_response::<C, B>(&self.client, versioned_proof);
					return Ok(Some(event_proof_response))
				}
			}
		}
		Ok(None)
	}
}

/// Build an `EventProofResponse` from a `VersionedEventProof`
pub fn build_event_proof_response<C, B>(
	client: &C,
	versioned_event_proof: VersionedEventProof,
) -> EventProofResponse
where
	B: Block<Hash = H256>,
	C: ProvideRuntimeApi<B> + Send + Sync + 'static,
	C::Api: EthyRuntimeApi<B>,
{
	match versioned_event_proof {
		VersionedEventProof::V1(event_proof) => {
			let proof_validator_set = client
				.runtime_api()
				.validator_set(&BlockId::hash(event_proof.block.into()))
				.ok()
				.unwrap();

			let validator_addresses: Vec<[u8; 20]> = proof_validator_set
				.validators
				.into_iter()
				.map(EthyEcdsaToEthereum::convert)
				.collect();

			EventProofResponse {
				event_id: event_proof.event_id,
				signatures: event_proof
					.expanded_signatures(validator_addresses.len())
					.into_iter()
					.map(|s| s.deref().to_vec())
					.map(|s| {
						sp_core::ecdsa::Signature::try_from(s.as_ref())
							.expect("signatures are 65 bytes")
					})
					.collect(),
				validators: validator_addresses,
				validator_set_id: proof_validator_set.id,
				block: event_proof.block,
				tag: event_proof.tag.clone(),
			}
		},
	}
}
